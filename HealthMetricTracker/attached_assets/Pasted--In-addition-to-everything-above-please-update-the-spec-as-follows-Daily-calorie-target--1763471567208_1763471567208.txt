
In addition to everything above, please update the spec as follows.

---

## Daily calorie target (default 3000 kcal) and UI control

1. **Database / model change**

   - Add a column `daily_calorie_target` (float, nullable) to the `daily_metrics` table.
   - When importing the CSV or creating a new row:
     - If `daily_calorie_target` is `NULL`, set it to a **default of 3000.0 kcal**.
   - Expose this field in the relevant Pydantic schemas and API responses.

2. **API changes**

   - For `GET /api/daily-metrics` and `GET /api/daily-metrics/{date}`, include `daily_calorie_target` in the response.
   - For `POST /api/daily-metrics` (upsert):

     - Allow an optional `daily_calorie_target` field in the request body:

       ```json
       {
         "date": "2025-11-18",
         "steps": 12000,
         "weight_kg": 90.5,
         "calories_burned_total": 2600,
         "calories_eaten": 2400,
         "daily_calorie_target": 2800
       }
       ```

     - If `daily_calorie_target` is provided, update that day’s target.
     - If it is omitted and the row does not exist yet, default to `3000.0`.
     - If it is omitted and the row exists, leave the existing target unchanged.

   - For `GET /api/daily-summary/{date}` (described earlier):

     - Always include `daily_calorie_target` in the JSON.
     - Compute and include:
       - `percentage_of_target = calories_eaten / daily_calorie_target * 100` (if target is non-null and > 0).
       - `remaining_to_target = daily_calorie_target - calories_eaten` (can be negative if over target).

3. **Frontend: change target via UI**

   - On the main page, near the date selector and daily metrics form, add a **“Daily calorie target”** number input.
   - Behaviour:

     - When the date changes, load that day’s `daily_calorie_target` from the API and populate the input.
     - If there is no target stored, default the input to **3000**.
     - When I edit the target and click “Save” (same button as for the daily metrics is fine), send `daily_calorie_target` in the `POST /api/daily-metrics` payload for that date.
     - After saving, refresh the table, charts, and summary so that they all reflect the new target.

   - The **progress bar / circular visual** for calories (added earlier) should use this `daily_calorie_target` as its reference:

     - Show “X / Y kcal” where:
       - X = `calories_eaten`
       - Y = `daily_calorie_target`
     - Colour the bar based on:
       - Under target and in deficit (for example, green).
       - Over target (for example, red).

4. **Plain English summary update**

   - Update the logic that builds `summary_text` in `GET /api/daily-summary/{date}` so it takes the new target into account dynamically.

   Example types of messages:

   - If under target and in deficit:

     > “You have eaten 1,850 kcal out of your 3,000 kcal target (62%). You are currently in a deficit of 700 kcal compared with your total burn. You have about 1,150 kcal left if you want to hit today’s target.”

   - If over target but still in deficit:

     > “You are 200 kcal over your 2,200 kcal target today, but still 300 kcal below your total burn. If you want to keep a bigger deficit, consider eating a little less or moving more tomorrow.”

   - If over both target and burn:

     > “You are 500 kcal over your 2,500 kcal target and 200 kcal above your total burn today. If your goal is fat loss, you may want to aim for a small deficit again tomorrow.”

   This should all be done with simple conditional logic on the backend, no external LLM required.

---

## Only input total calories burned (no active/basal in UI)

I do **not** want to manually enter active and basal calories in the UI. I only want to input **total calories burned**.

Please adjust the spec and implementation as follows:

1. **Database**

   - Keep the existing columns:
     - `calories_burned_total`
     - `calories_burned_active`
     - `calories_burned_basal`
   - These last two should be **optional / nullable only**, used primarily by the initial CSV import if present.
   - All subsequent manual input from the UI only updates `calories_burned_total` (and leaves `calories_burned_active` and `calories_burned_basal` unchanged or null).

2. **API**

   - In the `POST /api/daily-metrics` endpoint:
     - Make `calories_burned_total` the primary, user-facing field.
     - `calories_burned_active` and `calories_burned_basal` should be optional and generally not required in requests.
   - When computing `calorie_balance`, always use:
     - `calorie_balance = calories_eaten - calories_burned_total`
     - If `calories_burned_total` is null or 0, handle gracefully (for example, treat as 0 and explain in the summary that burn has not been entered yet).

3. **Frontend**

   - In the daily metrics form:

     - **Remove** the manual input fields for “Active calories” and “Basal calories”.
     - **Keep only**:
       - Steps
       - Weight (kg)
       - **Total calories burned**
       - Calories eaten
       - Daily calorie target

   - The charts and summaries should never expect the user to know the breakdown by active/basal. If those values exist from the initial import, you may still show them in a secondary detail view, but they are not required for ongoing manual use.

4. **Summary and visuals**

   - All summaries and visuals that compare intake to expenditure should use `calories_burned_total` and the current `daily_calorie_target`.
   - If `calories_burned_total` is missing for a given date, the summary text should explicitly say something like:

     > “You have eaten 1,900 kcal out of your 3,000 kcal target (63%). You have not entered today’s total calories burned yet, so your energy balance cannot be calculated.”

Please integrate these changes into the existing specification and generated code, so that:

- My **default daily calorie target is 3,000 kcal**, customisable per day via the UI.
- When I change the target, all related metrics (remaining calories, percentage of target, colour-coding, summaries, etc.) update accordingly.
- I **only have to enter total calories burned**, not active and basal components, while the app still supports the initial CSV fields for those if present.
In addition to EVERYTHING previously specified, extend the app with:

==================================================
A. WEIGHT GOAL MODES (MAINTENANCE VS WEIGHT LOSS)
==================================================

### 1. User-level settings and modes

Create a `user_settings` table (assume a single user, 1 row only):

- `id` (integer primary key, default 1)
- `maintenance_calories` (float, default **3000.0**)
- `current_mode` (string / enum)
  - allowed values:
    - `"maintenance"`
    - `"loss_gentle"`
    - `"loss_standard"`
    - `"loss_aggressive"`
- `deficit_gentle` (float, default **250.0**)
- `deficit_standard` (float, default **500.0**)
- `deficit_aggressive` (float, default **750.0**)

Add endpoints:

- `GET /api/settings` → returns the single settings row.
- `POST /api/settings` → updates:
  - `maintenance_calories`
  - `current_mode`
  - optionally the three deficit values.

### 2. How to compute the daily calorie target from mode

For a given day, the **recommended** calorie target is:

```text
if mode == "maintenance":      target = maintenance_calories
if mode == "loss_gentle":      target = maintenance_calories - deficit_gentle
if mode == "loss_standard":    target = maintenance_calories - deficit_standard
if mode == "loss_aggressive":  target = maintenance_calories - deficit_aggressive
Never allow the computed target to go below a safe floor, e.g. 1200 kcal. Clamp to this minimum.

Extend daily_metrics:

Add a column mode (string / enum with same values as above).

When a new day is created (via CSV import or manual first save):

If mode is null, set it to whatever current_mode is at that time.

If daily_calorie_target is null, compute it from user_settings and that mode using the formula above.

Extend the existing POST /api/daily-metrics request body to allow an optional mode. If present, recalculate daily_calorie_target from the current maintenance_calories and deficits.

3. UI for changing mode & maintenance
On the frontend, add a top-level “Goal mode” section:

A dropdown for:

Maintenance

Weight loss (gentle)

Weight loss (standard)

Weight loss (aggressive)

A numeric input for “Maintenance calories” (default 3000).

Behaviour:

On page load, call GET /api/settings to populate the dropdown and maintenance calories.

When I change the dropdown or maintenance calories and hit “Update goal”, call POST /api/settings.

For the currently selected date in the daily form:

Show the active mode and daily_calorie_target.

If I change the mode for that day (e.g. via another dropdown near the date picker), the frontend sends mode in the POST /api/daily-metrics payload, and the backend recalculates that day’s daily_calorie_target using the current maintenance_calories and deficits.

4. Summary text aware of mode and aggressiveness
Update the GET /api/daily-summary/{date} endpoint so that the summary_text explicitly references the mode, for example:

Maintenance mode:

“You are in maintenance mode with a target of 3,000 kcal. You’ve eaten 2,750 kcal (92% of target) and burned 2,600 kcal, so you are in a surplus of 150 kcal today.”

Gentle loss:

“You are in gentle weight loss mode (≈250 kcal daily deficit). Today your target is 2,750 kcal. You’ve eaten 2,400 kcal (87% of target) and burned 2,700 kcal, giving you a deficit of 300 kcal, which is on track for gentle loss.”

Aggressive loss:

“You are in aggressive weight loss mode (≈750 kcal daily deficit). Your target is 2,250 kcal. You’ve eaten 2,600 kcal (115% of target) and are currently 350 kcal over today’s goal. Consider tightening intake or increasing activity if you want to maintain this rate of loss.”

The mode logic should influence wording and whether the tone is “on track / above / below target”.

==================================================
B. PROTEIN METRIC (DAILY + ENTRY LEVEL)
1. Database changes
Extend daily_metrics with:

protein_total_g (float, nullable)

protein_target_g (float, nullable)

Extend calorie_entries with:

protein_g (float, nullable)

2. Aggregation rules
When calorie entries for a date are created/updated/deleted, compute:

text
Copy code
protein_total_g = SUM(calorie_entries.protein_g for that date)
calories_eaten  = SUM(calorie_entries.calories for that date)
and update the daily_metrics row accordingly.

protein_target_g can be:

Manually editable per day.

Defaulted to something simple like weight_kg * 1.6 if weight_kg is present, otherwise a static default (e.g. 160 g). You can implement either; at minimum, allow manual override via the daily form.

3. API & summary
Include protein_total_g and protein_target_g in:

GET /api/daily-metrics

GET /api/daily-summary/{date}

In GET /api/daily-summary/{date}, compute:

protein_percentage = protein_total_g / protein_target_g * 100 (when target is present).

Add this to the JSON, and include in summary_text, for example:

“You’ve eaten 135 g of protein out of a 160 g target (84%). Protein intake is close to your goal for supporting muscle and satiety.”

4. Frontend
In each calorie entry row, add a numeric input for Protein (g).

In the daily summary box and/or charts, show:

A small progress bar: protein_total_g vs protein_target_g.

==================================================
C. “OVERCOMING BINGE EATING” STYLE ENTRY COLUMNS
You already created a calorie_entries table. Extend it to support the CBT-E style columns:

For each entry:

date (date)

time (time/datetime)

food_and_drink (text)

place (text, e.g. “Desk”, “AA meeting”, “Restaurant”, “Bed”)

calories (float)

protein_g (float)

star_flag (string, nullable) // corresponds to the “*” column; treat as free text or simple markers

vl_flag (string, nullable) // corresponds to the “V/L” column (e.g. vomiting/laxative; store as “V”, “L”, “V+L”, or empty string)

context_comments (text, nullable) // corresponds to “Context and comments”

Additionally, include a field:

planned_slot (string, nullable) // values like “Breakfast”, “Mid-morning snack”, “Lunch”, “Afternoon snack”, “Dinner”, “Evening snack”

This planned_slot corresponds to the last column in your example where you label entries as “Breakfast”, “Lunch”, “Snack”, “Dinner”, etc.

1. API
Update the calorie entry endpoints to handle these fields:

GET /api/calorie-entries/{date} → return all of the above fields for each entry.

POST /api/calorie-entries → accept JSON with these keys and create/update entries.

DELETE /api/calorie-entries/{entry_id} remains the same.

2. Frontend UI for CBT-E fields
For the Calorie Entries section for a selected date:

When adding a new entry, the form should allow:

Time (default now)

Food and drink (full text area, to paste lines like:

“Nakd bar: 135 kcal, 3 g protein
Jumbo king prawns, 400 g ≈ 368 kcal, 72.4 g protein”

Place (free text)

Calories (numeric)

Protein (g, numeric)

Star flag (simple text input or checkbox that sets a symbol, e.g. *)

V/L (dropdown: empty / “V” / “L” / “V+L”)

Planned slot (dropdown with:

Breakfast

Mid-morning snack

Lunch

Afternoon snack

Dinner

Evening snack

“Other snack”)

Context & comments (multi-line text area, e.g. “Felt anxious after work”, “At AA meeting”, etc.)

Display entries in a table with columns:

Time

Food & drink consumed

Place

*

V/L

Calories

Protein (g)

Planned slot

Context & comments

[Delete] button

This table should visually resemble the CBT-E food diary layout you provided.

==================================================
D. VISUALS UPDATED FOR MODE + PROTEIN
Update the charts/visuals to incorporate the new concepts:

Calories vs target by mode

The existing “calories eaten vs target vs burned” chart should use the mode-dependent daily_calorie_target.

Colour the bar or line differently depending on whether the day is:

Maintenance

Gentle loss

Standard loss

Aggressive loss

Protein progress

Add a small chart or indicator showing protein intake vs protein target for the selected date and optionally as a trend over the last N days.

Daily summary text

Ensure the summary_text returned by GET /api/daily-summary/{date} now incorporates:

The selected mode and what it implies.

Position vs daily_calorie_target.

Calorie balance vs total burn.

Protein intake vs protein target.

A short, plain-English assessment like:

“In gentle weight loss mode you are on track today…”

“In maintenance mode you’re a bit above target…”

“Protein is low/high compared with your goal…”

Please integrate all of these additions into the existing project spec and code so that:

I can switch between maintenance and different weight loss tiers.

The default maintenance calories is 3000 kcal, adjustable via the UI.

The system handles protein per entry and per day.

Each food entry mirrors the CBT-E diary columns (time, food and drink, place, *, V/L, context & comments, and meal slot).

makefile
Copy code