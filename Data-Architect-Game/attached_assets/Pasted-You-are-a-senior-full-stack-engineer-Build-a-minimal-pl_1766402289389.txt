You are a senior full stack engineer. Build a minimal playable MVP of a grand strategy simulation game called “Insight Empire”, where the map is an enterprise data estate and the player deploys and scales an analytics stack.

Tech constraints
- Use Next.js (App Router) + TypeScript.
- Use Tailwind CSS for styling.
- Use Zustand for client state management.
- No external backend required for MVP, persist state to localStorage.
- Use deterministic simulation (seeded RNG) so runs are repeatable.
- Use simple data models and keep code clean, typed, and well commented.

Deliverable
- A working web app with a playable loop: choose scenario → take turns → deploy capabilities → resolve events → win/lose.
- Include a short tutorial overlay and a “Reset Run” button.

Game concept (must implement)
- The “map” is a graph of nodes representing:
  - Business Units (Finance, Ops, Product)
  - Applications (ERP, CRM, Support)
  - Data Platforms (Warehouse, Lake, Query Engine)
  - Domains (Orders, Customers, Revenue, Tickets)
- Render the map as a simple 2D graph view (SVG is fine). Nodes should show small badges for Adoption, Trust, Latency, Cost impact.
- Let the player click a node to view details and available actions.

Core resources / metrics tracked (global)
- Adoption (0–100)
- Trust (0–100)
- Latency (ms, target lower)
- Cost (£ per turn, target lower)
- Governance coverage (0–100)
- Reliability (0–100)
- Political capital (0–100)
- Support load (tickets per turn)

Capabilities (deployable mechanics)
Implement 3 capabilities in MVP:
1) Simba Connectors (ODBC/JDBC)
   - Deploy action: “Install driver + configure auth” on an Application or Data Platform node.
   - Effects: improves connectivity and performance (lower latency), increases governance risk if auth is weak, increases support load if versions drift.
2) Logi Symphony VDD (self-service discovery)
   - Deploy action: “Enable VDD pilot” on a Business Unit node.
   - Effects: boosts adoption quickly, reduces trust if governance is low, increases support load if templates not used.
3) Logi Symphony Managed Dashboards
   - Deploy action: “Publish governed dashboards” on a Business Unit node.
   - Effects: increases trust and reliability, moderates adoption growth, reduces support load long term, costs more upfront.

Actions per turn (player chooses up to 2)
- Deploy capability (above)
- Run enablement (training/templates): decreases support load, increases adoption, small cost
- Add governance policy: increases governance coverage + trust, reduces adoption temporarily, increases political friction
- Performance tuning: reduce latency and improve reliability, costs time and political capital

Event deck (10 cards)
Implement an event draw each turn (or every 2 turns). Each card has trigger conditions and outcomes. Use these 10:
1) Auth model change (OAuth scope shift) → increases support load, reduces reliability unless governance coverage ≥ 60
2) Schema drift → reduces trust unless Managed Dashboards deployed OR governance coverage ≥ 70
3) High-cardinality dashboard pain → increases latency unless performance tuning done last 2 turns
4) Exec mandate for AI search → political capital boost, but trust penalty if governance < 60
5) Central IT veto threat → blocks new deployments for 1 turn unless political capital ≥ 60
6) Licensing surprise → cost spike unless adoption < 50 or you take “Cut scope” choice
7) P1 incident → reliability drop, must spend an action on incident response next turn
8) Stalled adoption → adoption stops growing unless you run enablement
9) Data access denied → blocks connectivity on one node unless you spend political capital
10) Shadow IT breakout → adoption penalty unless you publish managed dashboards quickly

Turn resolution rules
- At end of each turn, calculate metric deltas from:
  - Active deployments per node
  - Last turn actions
  - Event outcomes
- Use simple, readable formulas. Ensure trade-offs:
  - Speed-to-value actions raise adoption but can lower trust/governance.
  - Governance actions raise trust but can slow adoption and cost political capital.
  - Performance tuning reduces latency but costs political capital and/or cost.
- Keep the sim bounded (no negative metrics, cap 0–100 where appropriate).

Win / lose conditions (for a 12-turn run)
- Win if by Turn 12:
  - Adoption ≥ 75
  - Trust ≥ 75
  - Governance coverage ≥ 70
  - Reliability ≥ 70
  - Average latency ≤ 1200 ms
  - Cost per turn ≤ £120 (or total cost ≤ £1500)
- Lose immediately if:
  - Trust ≤ 15 (trust collapse)
  - Reliability ≤ 15 (constant incidents)
  - Political capital ≤ 10 (blocked by politics)

Scenarios (3 presets)
1) Speed-to-value: low governance start, high adoption pressure
2) Governance-first: strict security, slower adoption, higher starting governance
3) Scale-out enterprise: more nodes, higher concurrency pressure, more events

UI requirements
- Main screen: left panel objectives and current turn, centre map graph, right panel node details + action buttons.
- Top bar: global metrics (mini cards).
- Event modal: shows event text + 1–2 choices when relevant.
- End screen: results summary + timeline of key events/actions.

Implementation steps
1) Create typed models: Node, Edge, Deployment, Metrics, Action, EventCard, Scenario.
2) Build state store with Zustand + localStorage persistence.
3) Build simulation engine functions:
   - applyAction(state, action)
   - drawEvent(state, rng)
   - resolveTurn(state)
4) Build UI components:
   - MapGraph (SVG)
   - MetricsBar
   - NodePanel
   - ActionsPanel
   - EventModal
   - TutorialOverlay
5) Add seeded RNG (e.g. mulberry32) with seed stored in run state.

Quality bar
- Code must run without errors.
- Keep it minimal but complete, with good types and separation of concerns.
- Provide a README in the repo with how to run, how the rules work, and where to tweak balance.

Now implement the full app.
